# CSS記述のベストプラクティス

CSSはWebの見た目を表現するための言語です。

CSSを利用して様々なWebデザインを再現することが可能ですが、

CSSの記述は管理しずらく、気を抜くと、すぐさま、複雑で読みにくいコードになりがちです。

管理しやすく、可読性に優れたCSS記述のために、必要なポイントをいくつか押さえておきましょう。

## CSSのリセットを記述する

CSSはWebサイトのデザインを表現するために、各種ブラウザ上で解釈されます。

ブラウザは、それぞれ固有に標準のCSSや、個別のCSS解釈を持っていることが多く、
まっさらの状態からCSSを記述すると、ブラウザごとの表示差異が大きく現れてしまうケースもあります。

このような問題を解決するためにリセットCSSと呼ばれるものが用意されており、
有名なものでは、normalize.cssなどがよく用いられています。

https://necolas.github.io/normalize.css/

一般的なCSSフレームワークなども標準でこのようなリセットCSSを内包しているケースが多く、
CSS記述を始めるにあたっては、何かしらのCSSフレームワークを利用するか、
リセットCSSを利用することが非常に重要です。

## ブロック要素とインライン要素を理解する

HTML上の要素は、大きくブロック要素とインライン要素に分かれます。

ブロック要素は、divやsectionなどのHTMLで記述される要素で、
通常フローに置いて、要素の前後に改行を生成します（他の要素と横に並ばない）。

インライン要素は、aやspanなどのHTMLで記述される要素で、
通常フローに置いて、要素の前後に改行を生成せず、インライン要素同士は横並びで表示されます。

CSS要素の中には、 ブロック要素でしか適用されないものが存在するため、
ブロック・インラインの種別には注意が必要です。

例えば `height` `width` `margin` `padding` など [CSS基本ボックスモデル](https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Box_Model)
を定義するプロパティはブロック要素でのみ有効なプロパティとなります。

HTMLの各要素は、要素ごとに標準のブロック・インラインの区別を持っていますが、
CSSプロパティの `display` を用いてこれを変更することも可能です。

https://developer.mozilla.org/ja/docs/Web/CSS/display-outside

## ブロック要素の垂直・水平中央揃え

ブロック要素を親要素に対して水平中央揃えする場合は、
左右のマージンをautoで設定します。

```
.box{
  width: 200px;
  margin-right: auto;
  margin-left: auto;
}
```

想像に反して、`margin-top` `margin-bottom` の値を `auto` で設定しても、
垂直方向で中央に配置されることはありません。

水平方向の中央揃えを行いたい場合には `flexbox` の `align-items: center` を用いると良いでしょう。

[align-items | MDN](https://developer.mozilla.org/ja/docs/Web/CSS/align-items#)

## 高さの記述は極力避ける

htmlにおける高さの記述は、極力避けるようにしましょう。

特にSPサイトのコーディングにおいて、高さの固定は柔軟な画面幅の変更に要素が追従できなくなるため、
必要なケースを除いて、記述を避ける方が良いでしょう。

デザインの必要上heightで高さを指定する場合、
要素があふれた場合の挙動をoverflowで必ず指定するようにしましょう。

## 固定表示を極力避ける

position:absoluteなどの固定表示を利用する記述は、
便利な反面、周囲のデザインを変更した際に、変更に柔軟に対応できないと言う問題があります。

コーディングを行う際には、極力こうした記述を避け、
シンプルに別の記述で解決できる方法がないか、相談してみましょう。

## カスケードを利用する

CSSはhtmlの親子関係をベースに、親のスタイルを子に継承することができます。

CSSのこの性質を利用することにより、CSSの記述を大幅に削減することが可能です。

例えば、以下のようなコードを見てましょう。

このcolorの記述は以下のようにまとめることができます。

## 様々な単位を活用する

### `px`

`px` は画面のピクセルサイズで指定する最も一般的な単位です。

`1px` は実際の画面解像度における `1px` とは異なり、ブラウザ上での論理解像度の `1px` とは異なります。

画面解像度の `1px` とブラウザ上での `1px` の差のことをデバイスピクセル比（device pixel ratio) といい、
最近のモバイル端末では `2-4` 程度の値が取られているようです。

モバイル端末で画像がぼやけるといった問題は、このデバイスピクセル比に起因するもので、
ターゲット端末のデバイスピクセル比に対して適切なサイズの画像を用意しなければなりません。

### `%` 

`%` は　親要素に対する相対的な割合を指定する際に有効な単位です。

コンテナ幅 = 画面サイズのような、幅が変化するデザインにおいては、
幅の指定を `%` でコーディングするか、
`max-width` などの指定を行い、コンテナから要素が溢れてしまうことのないように注意しましょう。

### `em`

emは要素のフォントサイズ（文字の高さ）を `1em` とする単位です。

font-sizeで `em` を利用する場合、親要素（親要素がない場合はルート）のfont-sizeを1emとする値になります。
それ以外の値にemを使用した場合、 その要素のfont-sizeを1emとする値になります。 

文字サイズに合わせてデザインを行いたい場合に便利で、 
例えば1文字分の余白を左右に設けたい、といった場合では、以下のようなCSSを記述することができます。

```css
.text{
    padding: 0 1em;
}
```

### `rem`

`em` が現在の要素のフォントサイズに対する単位だったのに対し、
`rem` はルートのフォントサイズに対する単位として機能します。

ルートのフォントサイズは通常、以下のようにして `html` 要素に対するCSS定義で指定します。

```css
html{
    font-size: 10px;
}
```

ブラウザは標準ではルートのフォントサイズが16pxになっているケースがほとんどですが、
コーディングでpxの代わりにremを多用する場合、
サイト内で、`x rem` の値を計算するのを簡便にするために、ルートのフォントサイズを `10px` に設定するケースが多いようです。

またブラウザのフォントサイズをユーザが変更している場合等に考慮して、
直接10pxと指定するのではなく `font-size: 62.5%` として標準 `10px` を再現する場合もあります。

また、ルートに対するフォントサイズ指定であることを明記するために 
`html` の代わりに `:root` を用いることもできます。

```css
:root{
    font-size: 10px;
}
```

`:root`は、詳細度が高いことを除けば `html` と同等です。


https://developer.mozilla.org/ja/docs/Web/CSS/:root

### `vw` `vh`

`vw` `vh` は画面の高さ、幅に依存した単位として機能します。

100vwは画面幅と、 100vhは画面の高さと同等です。
概ねルートに対する `%` と同じような働きをしますが、
`vw` `vh` はブラウザのスクロールバーも含んだサイズとなる点が `%` と異なります。

`vw` を利用して画面幅に合わせて変化する正方形のCSS定義を行うことができます。

```css
.box{
    width: 20vw;
    height: 20vw;
}
```

## ブロックとマージンの管理

マージンの相殺は大きな問題です。

上下に並ぶコンテンツのうち、上の要素のmargin-bottomと下の要素のmargin-topはお互いに相殺され、
大きい方値のみがマージンとして適用されます。

<p data-height="265" data-theme-id="0" data-slug-hash="gZpZJQ" data-default-tab="css,result" data-user="mikakane" data-pen-title="CSS 実践講座 マージンの相殺" class="codepen">See the Pen <a href="https://codepen.io/mikakane/pen/gZpZJQ/">CSS 実践講座 マージンの相殺</a> by mikakane (<a href="https://codepen.io/mikakane">@mikakane</a>) on <a href="https://codepen.io">CodePen</a>.</p>

また、親要素内の小要素に設定されたマージンのうち、  
一番最初の小要素のmargin-topは、親要素のmargin-topとして認識され  
一番最後の子要素のmargin-bottomは親要素のmargin-bottomとして認識されます。
親要素がすでに `margin-top` `margin-bottom` を持っている場合、
大きい方の値が `margin` として適用されます。

この親子間でのマージンの相殺は、 以下のようなケースでは生じないため、更に注意が必要です。

- 親要素がborderを設定している場合
- 親要素がpaddingを設定している場合
- 親要素がインラインコンテンツをもつ場合
- 親要素に `overflow: hidden` が設定されている場合

[マージンの相殺 | MDN](https://developer.mozilla.org/ja/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)

マージンの仕様として相殺を理解するのはもちろん大事ですが、
全体でマージンの付け方のポリシーを設定するのも重要です。

上下でマージンを設定する場合相殺が起こるので、要素感の垂直方向のマージンは、
`margin-bottom` で設定するか、`margin-top` で設定するかを統一しておくのが良いでしょう。

通常サイトの開始いちでマージンが生じるケースは少ないので、
特に問題がない限り `margin-bottom` で統一するのがおすすめです。


## 詳細度の考え方

CSSを記述する上で、詳細度に関しても少し考慮する必要があります。

詳細度はCSSを適用する上での強さを表すセレクタの持つ数値です。
 
[https://developer.mozilla.org/ja/docs/Web/CSS/Specificity](https://developer.mozilla.org/ja/docs/Web/CSS/Specificity)
 
既存のCSS記述を別のCSS定義を用いて後から上書き変更しようとした場合、
元の詳細度よりも強い詳細度を用いる必要があります。

IDセレクタは、一般に非常に強い詳細度を持っているため、
クラス等で記述するCSSを用いてこれを上書きする事ができなくなってしまいます。

同様に `style` 属性を用いた直接のスタイル定義も、非常に強い詳細度を持つため、
他のCSSを用いてこれを上書き変更することができません。

クラスセレクタを利用したケースでも、子孫セレクタを用いた指定は、
継承を追うごとにどんどんと詳細度が高くなってしまいます。

<p data-height="265" data-theme-id="0" data-slug-hash="pqZBdY" data-default-tab="css,result" data-user="mikakane" data-pen-title="pqZBdY" class="codepen">See the Pen <a href="https://codepen.io/mikakane/pen/pqZBdY/">pqZBdY</a> by mikakane (<a href="https://codepen.io/mikakane">@mikakane</a>) on <a href="https://codepen.io">CodePen</a>.</p>

CSSセレクタにおける親子セレクタの深さ定義は、全体で上限を設ける方が良いでしょう。
