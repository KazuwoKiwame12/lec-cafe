# アプリケーションの設計

## アプリケーションの設計

アプリケーションを開発する上で、
特定の機能をクラスに分割してモジュール化することは、非常に重要な設計のポイントです。

開発の進行に伴って日々膨大に膨らんでいくコードを、
適切なサイズで **分割し**、**再利用可能な状態**にすることをモジュール化といいます。

モジュール化には、様々な設計の観点が重要となっており、
どのようなサイズで分割するか、どのような再利用性を担保するかなど、
適切な方法を考えなければなりません。

無作為に大量のクラスを生成してしまうと、大量のクラス同士で生まれる依存関係はとても複雑になり、
システム設計の全容を把握するのがとても困難になります。

アプリケーションの分割を考える上でいくつかの重要な観点がありますので、
まずは一般的なアプリケーション設計の考え方を確認してみましょう。

## Model View Controller

Model View Controller(MVC) パターンは、
古くから言われるアプリケーション構築の一般的なパターンです。

MVCパターンではアプリケーションの主要な処理を、
以下の3つに分割し、アプリケーション分割に重要な視点を与えてくれます。

- Model : アプリケーション内のデータ処理に関する部分
- Controller : アプリケーションにおける入力、制御に関する部分
- View : アプリケーションの振る舞いに関する部分

Laravelを利用した一般的なMPAでは、
Controller部分をLaravelのControllerが、
View部分をBladeが担当します。

REST APIの開発に置いても、
Controller部分はRouteが相当し、 View部分はResponseに関する処理が、
その担当を担います。

基本的なMVC構成のアプリケーション分割は、
フレームワークの機能を利用することで、簡単に分割することが可能となっているため、
開発者は単純にルートで記述される処理を、 ModelとViewに分けながら、
Controllerの外に定義するだけで、簡単にMVCを実現することができます。

### Fat Controller 

Controller内に多数の処理が記載される状況は、一般的にFat Controllerと呼ばれます。

ルートの起点であるコントローラは、ルートの処理を後から読み解くための開始地点でもあり、
可能な限りシンプルで明瞭に処理が記述されているべきです。

Controllerの内部のコードが膨大に膨らんでいる場合、
それらの処理を、適切にコード分割して、外部化する必要があるでしょう。

### Skinny Controller

Fat Controllerを改善し、Controller内の処理が適切に外部化された状態を、
Skinny Controllerと呼びます。

しかしながら、コントローラで行われるべき処理が、
全て別のクラスに定義されただけでは、かえってController内のコードを理解するために読むべきコードが
他のファイルに分散するだけで、コードの可読性が低下するのみとなります。

Skinny Controllerを目指す上で以下のようなコードはController層に残しておくのが適切でしょう。

- リクエストパラメータの取得に関する処理
- バリデーションに関する処理
- 振る舞いに影響するようなエラーハンドリングや処理に関する振り分けのロジック

ルートのパラメータやバリデーションに関する処理は、
ルートが固有に持つもので、そのような情報はモデル層に引き渡す必要もなく、
Controllerの内部で処理するのが良いでしょう。

また、ルートのパラメータなどの条件に応じて、
処理すべき内容やコールすべきロジック、Viewの処理が異なる場合の分岐も、
Controller内で明記されている方が、あとからコードを読み解くために必要な情報を明確に提供できるでしょう。

## レイヤードアーキテクチャ

MVCよりもより実践的なアプリケーション設計のアプローチとして、
レイヤードアーキテクチャと呼ばれるものがあります。

レイヤードアーキテクチャは、システムが持つ業務知識を **ドメイン** と呼び、
ドメインに関する処理と、それ以外とを区別するための設計フローです。

一般的には、以下の4層の形で理解されるケースが多いでしょう。

- Presentation : UIに関するロジック ( 画面/Viewなど )
- Application : アプリケーション制御に関するロジック
- Domain : 機能仕様・業務知識に関するロジック
- Infrastructure : DBや外部APIなどデータストアに関するロジック

レイヤードアーキテクチャでは、依存の方向性を
Presentation -> Application -> Domain -> Infrastructureの方向で定義しており、
上の層が下の層を利用する、という一方通行の依存フローを定義して、
クラス同士の関係性により明瞭な方針を与えています。

MVCでは、データに関する処理の部分がModelとのみ定義されており、
依存関係も、三角形の構造で複雑だったのに対し、
レイヤードアーキテクチャでは、Model層がDomainとInfrastuctureに分割されたのに加え、
依存の方向性も定義される等、より実践的なアプローチとなっています。

### オニオンアーキテクチャ

オニオンアーキテクチャでは、レイヤードアーキテクチャから発展して、以下のような依存の流れが定義されています。

- Presentation : UIに関するロジック ( 画面/Viewなど )
- Application : アプリケーション制御に関するロジック
- Domain Service : 機能仕様・業務知識に関する操作ロジック
- Domain Model : 機能・業務知識に関するデータロジック

ApplicationがInfrastructureに依存せず、より抽象的なDomain Modelに依存するようになります。

Infrastructure層に関する処理は、以下のような形で依存関係逆転の原則により、
逆方向の依存関係で定義されるようになります。

- Infrastructure : DBや外部APIなどデータストアに関するロジック
- Application : アプリケーション制御に関するロジック
- Domain Service : 機能仕様・業務知識に関する操作ロジック
- Domain Model : 機能・業務知識に関するデータロジック

上のような構造を図にすると玉ねぎ上のアーキテクチャ図ができるため、
オニオンアーキテクチャと呼ばれています。詳しくは以下の記事を参考にしてください。

https://qiita.com/little_hand_s/items/ebb4284afeea0e8cc752

## クラス設計の関心

様々な設計パターンを駆使してクラスを分割する上で、
忘れてはならないのが基本的なクラスの設計ルールです。

クラスの設計ルールとしては、 SOLID原則やパッケージ原則などが知られますが、
以下に重要で理解しやすいもののみ説明しておきます。

### 単一責務の原則

クラスは、たった1つの責任のためにコードが記述されるべきという考え方を「単一責務の原則（SRP)」
クラスが全うすべき責任の範囲が明確化されていない場合、1つのクラスが様々なことを行ってしまい、
異なる用途で複数箇所からクラスが依存されてしまうなどの問題が生じます。

原則、クラスは1つの責任を全うすべきですし、万一クラスが複数の問題に対して
適用可能な状態となっている場合には、インタフェースを用いて機能を分離（ISP:インタフェース分離の原則）する事が望ましいでしょう。

古くからクラスの設計としてSOLID原則という考え方がよく参照されます。
SOLID原則は以下の5つの考え方の頭文字をとったもので、1つ1つが柔軟なクラス設計を考える上での重要な指標になる考え方です。

- 単一責務の原則Single Responsibility Principle (SRP)
- オープンクローズドの原則Open Closed Principle (OCP)
- リスコフの置換原則Liskov Substitution Principle (LSP)
- インタフェース分離の原則Interface Segregation Principle (ISP)
- 依存性逆転の原則Dependency Inversion Principle (DIP)

### ステートレスなクラス設計

クラスはプロパティを用いて、その内部に状態をもたせることが可能ですが、
クラス内部に用意された状態は、時として条件付きバグの温床になります。

クラス内プロパティが特定の値に書き換えられているケースでのみAのメソドをコールすると例外が発生、
などと言ったバグは、原因検出も困難で障害調査のコストを大幅に増加させるでしょう。

この様な問題を回避するためには、クラスプロパティを利用せず、
単純なメソドのみを用いたクラス設計を行うのがベストです。

クラス内に用意された「状態」は一般的に「ステート」と呼ばれ、
クラス内に状態を持たないクラスをステートレスなクラス、と呼びます。
